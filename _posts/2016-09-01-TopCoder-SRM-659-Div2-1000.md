---
layout: post
title: "TopCoder SRM 659 Div2 1000 ApplesAndOrangesHard"
date: 2016-09-01 19:02:00
description: 'Solution for TopCoder SRM 659 Div2 1000.'
tags:
- greedy
- implementation
categories:
- TopCoder
---

# Description

有一个长度为$n$的$01$串,其中任意连续$m$个位置中最多只能有$\lfloor\frac m2\rfloor$个$1$.已知其中$K$个位置必须为$1$,求最多能有多少个$1$.数据保证有解.

$2\le n\le10^9,2\le m\le\min(n,10^5),0\le K\le50.$


# Solution

这题是Div2 250的强化版本.

在弱化版中,只要模拟一个显然的贪心,即尽可能地往前摆,无脑$O(n\cdot m)$模拟即可AC.

然而这题由于$n$的范围很大,需要换一种贪心的思路来做.

下面的思路是拜读了神犇Bgzc111的代码,以及听了[ShinFeb的教导](http://shinfeb.logdown.com/posts/828510)后本蒟蒻一点浅薄的认识,如果有什么不对请一定指出.

考虑没有限制的情况,那么最优解显然是每$m$个的位置的前$\lfloor\frac m2\rfloor$个位置(以及最后多出来的位置)放$1$.

但是那些强制为$1$的限制可能会打乱我们的**计划**.然后我们需要调整我们的计划.具体来说,我们需要把前面一个位置的$1$移动到当前的位置(这时预计的答案可能会减小),并且以后每个周期计划为的位置都要随之改变,因为这样才能保证计划中不会存在冲突.

大致思路就是这样,但是实现起来需要一点技巧.Bgzc111用了一个数组$lim[i]$,表示每个周期的第$i$个位置(说起来要把下标先改为从$0$开始,这样方便取模)从第$lim[i]$个周期开始就计划全都为$1$,或者$lim[i]=0$表示计划这个位置不为$1$.一旦遇到强制为$1$但是计划不为$1$的情况,就需要往前面找,找到一个可以调整的位置进行调整,并考虑答案是否减小.

具体的实现以及一些细节可以参考下面代码中的中文注释.

其实这题的那个$\lfloor\frac m2\rfloor$似乎可以改为其他数字.

这样做的复杂度是$O(m\cdot K)$.

# Code

```c++
#include <cmath>
#include <ctime>
#include <cctype>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cassert>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <vector>
#include <bitset>
#include <complex>
#include <iostream>
#include <algorithm>
#define fi first
#define se second
#define y1 jfskav
#define pb push_back
#define lson (k<<1)
#define rson (k<<1|1)
#define lowbit(x) ((x)&-(x))
#define siz(x) ((int)(x).size())
#define all(x) (x).begin(),(x).end()
#define debug(x) cout<<#x<<" = "<<(x)<<endl
#define rep(i,s,t) for(register int i=(s),_t=(t);i<_t;++i)
#define per(i,s,t) for(register int i=(t)-1,_s=(s);i>=_s;--i)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int ui;
typedef double db;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef vector<int> veci;
const int mod=(int)1e9+7,inf=0x7fffffff,dxy[]={-1,0,1,0,-1};
const ll INF=1ll<<60;
const db pi=acos(-1),eps=1e-6;
template<class T>void rd(T &x){
    x=0;
    char c;
    while(c=getchar(),c<48);
    do x=(x<<3)+(x<<1)+(c^48);
        while(c=getchar(),c>47);
}
template<class T>void rec_pt(T x){
    if(!x)return;
    rec_pt(x/10);
    putchar(x%10^48);
}
template<class T>void pt(T x){
    if(!x)putchar('0');
    else rec_pt(x);
}
template<class T>inline void ptn(T x){
    pt(x),putchar('\n');
}
template<class T>inline void Max(T &a,T b){
    if(b>a)a=b;
}
template<class T>inline void Min(T &a,T b){
    if(b<a)a=b;
}
template<class T>T gcd(T a,T b){
    return b?gcd(b,a%b):a;
}
inline void mod_add(int &a,int b,int m=mod){
    if((a+=b)>=m)a-=m;
}
inline void mod_minus(int &a,int b,int m=mod){
    if((a-=b)<0)a+=m;
}
int mod_pow(int a,int b,int m=mod){
    int res=1;
    for(;b;b>>=1,a=(ll)a*a%m)
        if(b&1)res=(ll)res*a%m;
    return res;
}
inline int calc_inv(int x,int m=mod){
    return mod_pow(x,m-2);
}


const int M=(int)1e5+5;

int lim[M];

class ApplesAndOrangesHard {
public:
    int maximumApples(int n, int m, veci arr) {
        int ans=n/m*(m>>1);// 没有限制的情况下预计的答案
        sort(all(arr));
        memset(lim,0,m<<2);
        rep(i,0,m>>1)lim[i]=1;
        // 一开始每个周期的前m>>1个位置预计为1,这里编号为1的周期是虚拟的,可以保证第一个周期能够往前找到调整的位置
        for(int elm:arr){
            --elm;// 考虑每个强制为1的位置
            int block=elm/m+2,pos=elm%m;// block表示这个位置所属周期,pos表示在周期中的位置
            if(!lim[pos]){// 如果这个位置预计不为1
                for(int pre=pos?pos-1:m-1;;mod_minus(pre,1,m)){
                    // 往前面找,pre表示前面位置在周期中的位置
                    if(!lim[pre]||lim[pre]==block||lim[pre]==block-1&&pre>pos)continue;
                    /*
                        三种不能调整的情况:
                        1.pre位置没有放1
                        2.当前周期强制pre必须放1
                        3.前一个周期强制pre必须放1,那么只能这个周期的pre位置调整,但是这个位置在后面
                        注意第lim[i]个周期的i位置是必须放1的,所以不能调整.
                    */
                    if(pre>pos)--ans;
                    lim[pre]=0;
                    /*
                        一定可以找到一个可以调整的位置(因为实时保证了后面的计划最优),
                        并且根据意识流应该选择最右边的位置进行调整,
                        这时如果pre<=pos则可以在之前的周期内把pre移动到pos位置而不影响答案,
                        否则要进行跨周期的调整,那么前面一个周期1的个数就会减1.
                        然后把lim[pre]改为0也不会有影响.
                    */
                    break;
                }
            }
            lim[pos]=block;// 以后的周期这个位置预计都为1
        }
        rep(i,0,n%m)if(lim[i])++ans;// 最后考虑不属于周期的位置
        return ans;
    }
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, int p1, vector <int> p2, bool hasAnswer, int p3) {
    cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << "{";
    for (int i = 0; int(p2.size()) > i; ++i) {
        if (i > 0) {
            cout << ",";
        }
        cout << p2[i];
    }
    cout << "}";
    cout << "]" << endl;
    ApplesAndOrangesHard *obj;
    int answer;
    obj = new ApplesAndOrangesHard();
    clock_t startTime = clock();
    answer = obj->maximumApples(p0, p1, p2);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer) {
        cout << "Desired answer:" << endl;
        cout << "\t" << p3 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer) {
        res = answer == p3;
    }
    if (!res) {
        cout << "DOESN'T MATCH!!!!" << endl;
    } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
        cout << "FAIL the timeout" << endl;
        res = false;
    } else if (hasAnswer) {
        cout << "Match :-)" << endl;
    } else {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main() {
    bool all_right;
    all_right = true;
    
    int p0;
    int p1;
    vector <int> p2;
    int p3;
    
    {
    // ----- test 0 -----
    p0 = 3;
    p1 = 2;
    p2.clear() /*{}*/;
    p3 = 2;
    all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
    // ------------------
    }
    
    {
    // ----- test 1 -----
    p0 = 10;
    p1 = 3;
    int t2[] = {3,8};
            p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
    p3 = 2;
    all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
    // ------------------
    }
    
    {
    // ----- test 2 -----
    p0 = 9;
    p1 = 4;
    int t2[] = {1,4};
            p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
    p3 = 5;
    all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
    // ------------------
    }
    
    {
    // ----- test 3 -----
    p0 = 9;
    p1 = 4;
    int t2[] = {2,4};
            p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
    p3 = 4;
    all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
    // ------------------
    }
    
    {
    // ----- test 4 -----
    p0 = 23;
    p1 = 7;
    int t2[] = {3,2,9,1,15,23,20,19};
            p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
    p3 = 10;
    all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
    // ------------------
    }
    
    {
    // ----- test 5 -----
    p0 = 1000000000;
    p1 = 17;
    int t2[] = {2110119,401933834,401933833,10};
            p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
    p3 = 470588238;
    all_right = KawigiEdit_RunTest(5, p0, p1, p2, true, p3) && all_right;
    // ------------------
    }
    
    if (all_right) {
        cout << "You're a stud (at least on the example cases)!" << endl;
    } else {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// END KAWIGIEDIT TESTING

/*
    
    Sept.01.16
    
    Tags:greedy,implementation
    
*/
```

